# -----------------------------------------------------------------------------
# This file is part of the xPack distribution.
#   (https://xpack.github.io)
# Copyright (c) 2020 Liviu Ionescu.
#
# Permission to use, copy, modify, and/or distribute this software 
# for any purpose is hereby granted, under the terms of the MIT license.
# -----------------------------------------------------------------------------

# Helper script used in the second edition of the xPack build 
# scripts. As the name implies, it should contain only functions and 
# should be included with 'source' by the container build scripts.

# -----------------------------------------------------------------------------

# https://stackoverflow.com/questions/44150871/embeded-python3-6-with-mingw-in-c-fail-on-linking

# -----------------------------------------------------------------------------

function build_python3() 
{
  # https://www.python.org
  # https://www.python.org/downloads/source/
  # https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tar.xz
  
  # https://archlinuxarm.org/packages/aarch64/python/files/PKGBUILD
  # https://git.archlinux.org/svntogit/packages.git/tree/trunk/PKGBUILD?h=packages/python
  # https://git.archlinux.org/svntogit/packages.git/tree/trunk/PKGBUILD?h=packages/python-pip

  # 2018-12-24, "3.7.2"
  # March 25, 2019, "3.7.3"
  # Dec. 18, 2019, "3.8.1"

  local python3_version="$1"

  PYTHON3_VERSION_MAJOR=$(echo ${python3_version} | sed -e 's|\([0-9]\)\..*|\1|')
  PYTHON3_VERSION_MINOR=$(echo ${python3_version} | sed -e 's|\([0-9]\)\.\([0-9][0-9]*\)\..*|\2|')
  PYTHON3_VERSION_MAJOR_MINOR=${PYTHON3_VERSION_MAJOR}${PYTHON3_VERSION_MINOR}

  # Version 3.7.2 uses a longer name, like python-3.7.2.post1-embed-amd64.zip.
  if [ "${TARGET_BITS}" == "32" ]
  then
    PYTHON3_WIN_EMBED_FOLDER_NAME=python-"${python3_version}-embed-win32"
  else
    PYTHON3_WIN_EMBED_FOLDER_NAME=python-"${python3_version}-embed-amd64"
  fi
  # Used in python3-config.sh
  export PYTHON3_WIN_EMBED_FOLDER_NAME

  export PYTHON3_SRC_FOLDER_NAME="Python-${python3_version}"

  local python3_archive="${PYTHON3_SRC_FOLDER_NAME}.tar.xz"
  local python3_url="https://www.python.org/ftp/python/${python3_version}/${python3_archive}"

  local python3_folder_name="python-${python3_version}"

  local python3_win_embed_pack="${PYTHON3_WIN_EMBED_FOLDER_NAME}.zip"
  local python3_win_embed_url="https://www.python.org/ftp/python/${python3_version}/${python3_win_embed_pack}"

  local python3_stamp_file_path="${STAMPS_FOLDER_PATH}/stamp-${python3_folder_name}-installed"
  if [ ! -f "${python3_stamp_file_path}" ]
  then

    cd "${SOURCES_FOLDER_PATH}"

    (
      xbb_activate

      download_and_extract "${python3_url}" "${python3_archive}" \
        "${PYTHON3_SRC_FOLDER_NAME}"
    )

    mkdir -pv "${LOGS_FOLDER_PATH}/${python3_folder_name}"

    (
      mkdir -pv "${BUILD_FOLDER_PATH}/${python3_folder_name}"
      cd "${BUILD_FOLDER_PATH}/${python3_folder_name}"

      xbb_activate
      # To pick the new libraries
      xbb_activate_installed_dev

      if false # [ "${TARGET_PLATFORM}" == "darwin" ]
      then
        # GCC fails with:
        # error: variably modified 'bytes' at file scope
        export CC=clang
        export CXX=clang++
      fi

      CPPFLAGS="${XBB_CPPFLAGS}"
      CFLAGS="${XBB_CFLAGS_NO_W}"
      CXXFLAGS="${XBB_CXXFLAGS_NO_W}"
      LDFLAGS="${XBB_LDFLAGS_APP_STATIC_GCC}"

      if [[ "${CC}" =~ gcc* ]]
      then
        # Inspired from Arch; not supported by clang.
        CFLAGS+=" -fno-semantic-interposition"
        CXXFLAGS+=" -fno-semantic-interposition"
        LDFLAGS+=" -fno-semantic-interposition"
      fi

      if [ "${IS_DEVELOP}" == "y" ]
      then
        LDFLAGS+=" -v"
      fi

      export CPPFLAGS
      export CFLAGS
      export CXXFLAGS
      export LDFLAGS

      env | sort

      if [ ! -f "config.status" ]
      then
        (
          echo
          echo "Running python3 configure..."

          bash "${SOURCES_FOLDER_PATH}/${PYTHON3_SRC_FOLDER_NAME}/configure" --help

          # Fail on macOS:
          # --enable-universalsdk
          # --with-lto

          # "... you should not skip tests when using --enable-optimizations as 
          # the data required for profiling is generated by running tests".

          # --enable-optimizations takes too long

          config_options=()
          config_options+=("--prefix=${LIBS_INSTALL_FOLDER_PATH}")

          config_options+=("--with-universal-archs=${TARGET_BITS}-bit")
          config_options+=("--with-computed-gotos")
          config_options+=("--with-dbmliborder=gdbm:ndbm")

          # Better not, allow configure to choose.
          # config_options+=("--with-system-expat")
          # config_options+=("--with-system-ffi")
          # config_options+=("--with-system-libmpdec")

          # config_options+=("--with-openssl=${INSTALL_FOLDER_PATH}")
          config_options+=("--without-ensurepip")
          config_options+=("--without-lto")
          
          if [ "${TARGET_PLATFORM}" == "linux" ]
          then
            # Workaround, patchelf damages the python shared libraries.
            config_options+=("--disable-shared")
          else
            config_options+=("--enable-shared")
          fi

          # config_options+=("--enable-loadable-sqlite-extensions")
          config_options+=("--disable-loadable-sqlite-extensions")

          if [ "${TARGET_PLATFORM}" == "linux" ]
          then
            config_options+=("--disable-new-dtags")
          fi

          run_verbose bash ${DEBUG} "${SOURCES_FOLDER_PATH}/${PYTHON3_SRC_FOLDER_NAME}/configure" \
            ${config_options[@]}
             
          cp "config.log" "${LOGS_FOLDER_PATH}/${python3_folder_name}/config-log.txt"
        ) 2>&1 | tee "${LOGS_FOLDER_PATH}/${python3_folder_name}/configure-output.txt"
      fi

      (
        echo
        echo "Running python3 make..."

        # export LD_RUN_PATH="${LIBS_INSTALL_FOLDER_PATH}/lib"

        # Build.
        run_verbose make -j ${JOBS} # build_all

        # make install-strip
        run_verbose make install

        # Hundreds of tests, take a lot of time.
        # Many failures.
        if false # [ "${WITH_TESTS}" == "y" ]
        then
          run_verbose make -j1 quicktest
        fi

      ) 2>&1 | tee "${LOGS_FOLDER_PATH}/${python3_folder_name}/make-output.txt"
    )

    (
      test_python3
    ) 2>&1 | tee "${LOGS_FOLDER_PATH}/${python3_folder_name}/test-output.txt"

    copy_license \
      "${SOURCES_FOLDER_PATH}/${PYTHON3_SRC_FOLDER_NAME}" \
      "${python3_folder_name}"

    touch "${python3_stamp_file_path}"

  else
    echo "Component python3 already installed."
  fi
}

function test_python3()
{
  (
    # xbb_activate_installed_bin

    echo
    echo "Checking the python3 binary shared libraries..."

    show_libs "${LIBS_INSTALL_FOLDER_PATH}/bin/python3"

    echo
    echo "Testing if python3 binary starts properly..."

    # export PYTHONHOME="${INSTALL_FOLDER_PATH}"
    # export PYTHONPATH="${INSTALL_FOLDER_PATH}/lib/python3.8"
    export LD_LIBRARY_PATH="${LIBS_INSTALL_FOLDER_PATH}/lib"
    run_app "${LIBS_INSTALL_FOLDER_PATH}/bin/python3" --version

    run_app "${LIBS_INSTALL_FOLDER_PATH}/bin/python3" -c 'import sys; print(sys.path)'
  )
}

# -----------------------------------------------------------------------------

function build_meson()
{
  local meson_version="$1"

  # https://mesonbuild.com
  # https://github.com/mesonbuild/meson/archive/0.55.1.tar.gz
  # https://github.com/mesonbuild/meson/releases
  # https://github.com/mesonbuild/meson/releases/download/0.55.1/meson-0.55.1.tar.gz

  # https://archlinuxarm.org/packages/aarch64/meson/files/PKGBUILD

  # Sep 11 2020, "0.55.3"

  local meson_src_folder_name="meson-${meson_version}"
  local meson_folder_name="${meson_src_folder_name}"

  # GitHub release archive.
  local meson_archive_file_name="${meson_src_folder_name}.tar.gz"
  # local meson_url="https://github.com/mesonbuild/meson/archive/${meson_version}.tar.gz"
  local meson_url="https://github.com/mesonbuild/meson/releases/download/${meson_version}/${meson_archive_file_name}"

  cd "${SOURCES_FOLDER_PATH}"

  (
    set +e
    # When extracting on macOS, tar reports an error related to the symlink,
    # but the extracted content seems fine.
    # tar: meson-0.55.1/test cases/common/227 fs module/a_symlink: Cannot utime: No such file or directory
  
    download_and_extract "${meson_url}" "${meson_archive_file_name}" \
      "${meson_src_folder_name}"
  )

  (
    mkdir -p "${BUILD_FOLDER_PATH}/${meson_folder_name}"
    cd "${BUILD_FOLDER_PATH}/${meson_folder_name}"

    mkdir -pv "${LOGS_FOLDER_PATH}/${meson_folder_name}"

    xbb_activate
    xbb_activate_installed_dev

    local exe=""
    if [ "${TARGET_PLATFORM}" == "win32" ]
    then
      prepare_gcc_env "${CROSS_COMPILE_PREFIX}-"
      exe=".exe"
    fi

    # gcc-xbb -pthread 
    # -L/Host/Users/ilg/Work/meson-build-0.55.1-1/linux-x64/install/libs/lib64
    # -L/Host/Users/ilg/Work/meson-build-0.55.1-1/linux-x64/install/libs/lib  
    # -O2 -Wl,--gc-sections -fno-semantic-interposition -v   
    # -Xlinker -export-dynamic -o python.exe Programs/python.o libpython3.8.a 
    # -lcrypt -lpthread -ldl  -lutil -lrt -lm   -lm 

    if [ "${TARGET_PLATFORM}" == "win32" ]
    then
      CPPFLAGS="${XBB_CPPFLAGS} -I${BUILD_FOLDER_PATH}/${meson_folder_name} -I${SOURCES_FOLDER_PATH}/Python-${PYTHON_VERSION}/Include -DPy_BUILD_CORE_BUILTIN=1"
    else
      CPPFLAGS="${XBB_CPPFLAGS} -I${LIBS_INSTALL_FOLDER_PATH}/include/python${PYTHON3_VERSION_MAJOR}.${PYTHON3_VERSION_MINOR} -DPy_BUILD_CORE_BUILTIN=1"
    fi
    CFLAGS="${XBB_CFLAGS_NO_W}"
    CXXFLAGS="${XBB_CXXFLAGS_NO_W}"
    LDFLAGS="${XBB_LDFLAGS_APP_STATIC_GCC}"
    if [ "${TARGET_PLATFORM}" == "win32" ]
    then
      LDFLAGS+=" -L${SOURCES_FOLDER_PATH}/${PYTHON3_WIN_EMBED_FOLDER_NAME}"
    elif [ "${TARGET_PLATFORM}" == "darwin" ]
    then
      LDFLAGS+=" -L${LIBS_INSTALL_FOLDER_PATH}/lib -fno-semantic-interposition"
    elif [ "${TARGET_PLATFORM}" == "linux" ]
    then
      # ${LIBS_INSTALL_FOLDER_PATH}/lib/libpython3.8.a
      LDFLAGS+=" -L${LIBS_INSTALL_FOLDER_PATH}/lib -fno-semantic-interposition -Xlinker -export-dynamic"
    fi
    if [ "${IS_DEVELOP}" == "y" ]
    then
      LDFLAGS+=" -v"
    fi

    # Python3 uses these two libraries.
    if [ "${TARGET_PLATFORM}" == "win32" ]
    then
      LIBS="-lpython${PYTHON3_VERSION_MAJOR} -lpython${PYTHON3_VERSION_MAJOR_MINOR}"
    elif [ "${TARGET_PLATFORM}" == "darwin" ]
    then
      LIBS="-lpython${PYTHON3_VERSION_MAJOR}.${PYTHON3_VERSION_MINOR} -lcrypt -lpthread -ldl  -lutil -lm"
    elif [ "${TARGET_PLATFORM}" == "linux" ]
    then
      LIBS="${LIBS_INSTALL_FOLDER_PATH}/lib/libpython${PYTHON3_VERSION_MAJOR}.${PYTHON3_VERSION_MINOR}.a ${LIBS_INSTALL_FOLDER_PATH}/lib/libcrypt.a -lpthread -ldl  -lutil -lrt -lm"
    fi

    CPPFLAGS+=" -DPYTHON_VERSION_MAJOR=${PYTHON3_VERSION_MAJOR}"
    CPPFLAGS+=" -DPYTHON_VERSION_MINOR=${PYTHON3_VERSION_MINOR}"

    if [ "${IS_DEBUG}" == "y" ]
    then
      CPPFLAGS+=" -DDEBUG"
    fi

    export CPPFLAGS
    export CFLAGS
    export CXXFLAGS
    export LDFLAGS
    export LIBS

    env | sort

    # Bring the meson source files into the build folder.
    cp -v "${BUILD_GIT_PATH}"/src/* .

    if [ "${TARGET_PLATFORM}" == "win32" ]
    then
      cp -v "${BUILD_GIT_PATH}/extras/includes/pyconfig-${PYTHON_VERSION}.h" \
        "pyconfig.h"
    fi

    run_verbose make meson${exe} V=1

    mkdir -pv "${APP_PREFIX}/bin"    
    install -v -m755 -c meson${exe} "${APP_PREFIX}/bin"

    show_libs "${APP_PREFIX}/bin/meson"
    prepare_app_libraries "${APP_PREFIX}/bin/meson"

    local python_with_version="python${PYTHON3_VERSION_MAJOR}.${PYTHON3_VERSION_MINOR}"
    if [ ! -d "${APP_PREFIX}/lib/${python_with_version}/" ]
    then
      (
        mkdir -pv "${APP_PREFIX}/lib/${python_with_version}/"

        echo
        echo "Copying .py files from the standard Python library..."

        # Copy all .py from the original source package.
        cp -r "${SOURCES_FOLDER_PATH}/${PYTHON3_SRC_FOLDER_NAME}"/Lib/* \
          "${APP_PREFIX}/lib/${python_with_version}/"

        echo "Copying mesonbuild .py code..."
        mkdir -pv "${APP_PREFIX}/lib/${python_with_version}/mesonbuild/"
        cp -r "${SOURCES_FOLDER_PATH}/${meson_src_folder_name}"/mesonbuild/* \
          "${APP_PREFIX}/lib/${python_with_version}/mesonbuild/"

        (
          echo "Compiling all python & meson sources..."
          # Compiling tests fails, ignore the errors.
          if [ "${TARGET_PLATFORM}" == "win32" ]
          then
            run_app "${SOURCES_FOLDER_PATH}/${PYTHON3_WIN_EMBED_FOLDER_NAME}/python" \
              -m compileall \
              -j "${JOBS}" \
              -f "${APP_PREFIX}/lib/${python_with_version}/" \
              || true
          else
            run_app "${LIBS_INSTALL_FOLDER_PATH}/bin/python3" \
              -m compileall \
              -j "${JOBS}" \
              -f "${APP_PREFIX}/lib/${python_with_version}/" \
              || true

          fi

          # For just in case.
          find "${APP_PREFIX}/lib/${python_with_version}/" \
            \( -name '*.opt-1.pyc' -o -name '*.opt-2.pyc' \) \
            -exec rm -v {} \;
        )

        echo "Replacing .py files with .pyc files..."
        move_pyc "${APP_PREFIX}/lib/${python_with_version}"

        mkdir -pv "${APP_PREFIX}/lib/${python_with_version}/lib-dynload/"

        echo
        echo "Copying Python shared libraries..."

        if [ "${TARGET_PLATFORM}" == "win32" ]
        then
          # Copy the Windows specific DLLs (.pyd) to the separate folder;
          # they are dynamically loaded by Python.
          cp -v "${SOURCES_FOLDER_PATH}/${PYTHON3_WIN_EMBED_FOLDER_NAME}"/*.pyd \
            "${APP_PREFIX}/lib/${python_with_version}/lib-dynload/"
          # Copy the usual DLLs too; the python*.dll are used, do not remove them.
          cp -v "${SOURCES_FOLDER_PATH}/${PYTHON3_WIN_EMBED_FOLDER_NAME}"/*.dll \
            "${APP_PREFIX}/lib/${python_with_version}/lib-dynload/"
        else
          # Copy dynamically loaded modules and rename folder.
          cp -r "${LIBS_INSTALL_FOLDER_PATH}/lib/python${PYTHON3_VERSION_MAJOR}.${PYTHON3_VERSION_MINOR}"/lib-dynload/* \
            "${APP_PREFIX}/lib/${python_with_version}/lib-dynload/"

          echo "Preparing Python shared libraries..."
          # on macOS the libraries use .so too.
          for file_path in "${APP_PREFIX}/lib/${python_with_version}"/lib-dynload/*.so
          do
            prepare_app_libraries "${file_path}"
          done
        fi
      )
    fi

    copy_license \
      "${SOURCES_FOLDER_PATH}/${meson_src_folder_name}" \
      "${meson_folder_name}"

  )

  tests_add "test_meson"
}

function process_pyc()
{
  local file_path="$1"

  # echo bbb "${file_path}"

  local file_full_name="$(basename "${file_path}")"
  local file_name="$(echo "${file_full_name}" | sed -e 's|\.cpython-[0-9]*\.pyc||')"
  local folder_path="$(dirname $(dirname "${file_path}"))"

  # echo "${folder_path}" "${file_name}"

  if [ -f "${folder_path}/${file_name}.py" ] 
  then
    mv "${file_path}" "${folder_path}/${file_name}.pyc"
    rm "${folder_path}/${file_name}.py"
  fi
}

export -f process_pyc

function process_pycache()
{
  local folder_path="$1"

  find ${folder_path} -name '*.pyc' -type f -print0 | xargs -0 -L 1 -I {} bash -c 'process_pyc "{}"'

  if [ $(ls -1 "${folder_path}" | wc -l) -eq 0 ]
  then
    rm -rf "${folder_path}"
  fi
}

export -f process_pycache

function move_pyc()
{
  local folder_path="$1"

  find ${folder_path} -name '__pycache__' -type d -print0 | xargs -0 -L 1 -I {} bash -c 'process_pycache "{}"'
}


# -----------------------------------------------------------------------------

function test_meson()
{
  time run_app "${APP_PREFIX}/bin/meson" --version

  run_app "${APP_PREFIX}/bin/meson" --help
  # TODO: Add a minimal test.
}

# -----------------------------------------------------------------------------
